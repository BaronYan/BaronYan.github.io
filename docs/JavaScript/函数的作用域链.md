



æ¥çœ‹çœ‹ä¸‹é¢çš„ä»£ç ï¼š

```javascript
const name = "Lydia"
const age = 21
const city = "San Francisco"

function getPersonInfo() {
  const name = "Sarah"
  const age = 22

  return `${name} is ${age} and lives in ${city}`
}

console.log(getPersonInfo())
```
We're invoking the `getPersonInfo` function, which returns a string containing the values of the `name`, `age` and `city` variables:  
æˆ‘ä»¬æ­£åœ¨è°ƒç”¨ getPersonInfo å‡½æ•°ï¼Œè¯¥å‡½æ•°å°†è¿”å›ä¸€ä¸ªåŒ…å«å§“åã€å¹´é¾„å’ŒåŸå¸‚å˜é‡å€¼çš„å­—ç¬¦ä¸²ï¼š`Sarah is 22 and lives in San Francisco`.

But, the `getPersonInfo` function doesn't contain a variable named city ğŸ¤¨? How did it know the value of city?

First, memory space is set up for the different contexts.  
é¦–å…ˆï¼Œä¸ºä¸åŒçš„ä¸Šä¸‹æ–‡è®¾ç½®å†…å­˜ç©ºé—´ã€‚  

We have the default global context (`window` in a browser, `global` in Node),   
æˆ‘ä»¬æœ‰é»˜è®¤çš„å…¨å±€ä¸Šä¸‹æ–‡ï¼ˆæµè§ˆå™¨ä¸­çš„`window`ï¼ŒNode ä¸­çš„ `global`ä¸Šä¸‹æ–‡ï¼‰ï¼Œ

and a local context for the `getPersonInfo` function which has been invoked.   
ä»¥åŠç”¨äºè°ƒç”¨ `getPersonInfo` å‡½æ•°çš„æœ¬åœ°ä¸Šä¸‹æ–‡ã€‚

Each context also has a scope chain.  
æ¯ä¸ªä¸Šä¸‹æ–‡è¿˜æœ‰ä¸€ä¸ªä½œç”¨åŸŸé“¾ã€‚

For the `getPersonInfo` function, the scope chain looks something like this :   
å¯¹äº `getPersonInfo` å‡½æ•°ï¼Œä½œç”¨åŸŸé“¾çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š

local execution context -> local scope chain
æœ¬åœ°æ‰§è¡Œä¸Šä¸‹æ–‡ -> æœ¬åœ°ä½œç”¨åŸŸé“¾

![ä½œç”¨åŸŸé“¾](../images/20240623001.png)

The scope chain is basically a "chain of references" to objects  
ä½œç”¨åŸŸé“¾åŸºæœ¬ä¸Šæ˜¯å¯¹è±¡çš„ "å¼•ç”¨é“¾"ï¼Œ  

that contain references to values (and other scopes) 
that are referencable in that execution context.   
å…¶ä¸­åŒ…å«å¯¹è¯¥æ‰§è¡Œä¸Šä¸‹æ–‡ä¸­å¯å¼•ç”¨çš„å€¼ï¼ˆå’Œå…¶ä»–ä½œç”¨åŸŸï¼‰çš„å¼•ç”¨ã€‚

In the following examples,  
åœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­ï¼Œ

the `key/value` pairs in the execution contexts represent the references that the scope chain has to the variables.  
æ‰§è¡Œä¸Šä¸‹æ–‡ä¸­çš„é”®/å€¼å¯¹è¡¨ç¤ºä½œç”¨åŸŸé“¾å¯¹å˜é‡çš„å¼•ç”¨ã€‚

![ä½œç”¨åŸŸé“¾å¯¹å˜é‡çš„å¼•ç”¨](../images/20240623002.png)

The scope chain of the global execution context has a reference to 3 variables: name with the value Lydia, age with the value 21, and city with the value San Francisco.   
å…¨å±€æ‰§è¡Œä¸Šä¸‹æ–‡çš„ä½œç”¨åŸŸé“¾å¼•ç”¨äº† 3 ä¸ªå˜é‡ï¼šå§“åï¼ˆå€¼ä¸º Lydiaï¼‰ã€å¹´é¾„ï¼ˆå€¼ä¸º 21ï¼‰å’ŒåŸå¸‚ï¼ˆå€¼ä¸ºæ—§é‡‘å±±ï¼‰ã€‚

In the local context, we have a reference to 2 variables: name with the value Sarah, and age with the value 22.  
åœ¨æœ¬åœ°ä¸Šä¸‹æ–‡ä¸­ï¼Œæˆ‘ä»¬å¼•ç”¨äº† 2 ä¸ªå˜é‡ï¼šå§“åï¼ˆå€¼ä¸º Sarahï¼‰å’Œå¹´é¾„ï¼ˆå€¼ä¸º 22ï¼‰ã€‚

When we try to access the variables in the `getPersonInfo` function, the engine first checks the local scope chain.  
å½“æˆ‘ä»¬å°è¯•è®¿é—® `getPersonInfo` å‡½æ•°ä¸­çš„å˜é‡æ—¶ï¼Œå¼•æ“ä¼šé¦–å…ˆæ£€æŸ¥æœ¬åœ°ä½œç”¨åŸŸé“¾ã€‚

![æœ¬åœ°ä½œç”¨åŸŸé“¾](../images/20240623003.gif)

In the global context,  
åœ¨å…¨å±€ä¸Šä¸‹æ–‡ä¸­ï¼Œ

we declared the variable city with the value of San Francisco,  
æˆ‘ä»¬å£°æ˜äº†å€¼ä¸º San Francisco çš„å˜é‡ cityï¼Œ

thus has a reference to the variable city.  
å› æ­¤æœ‰äº†å¯¹å˜é‡ city çš„å¼•ç”¨ã€‚

Now that we have a value for the variable,  
ç°åœ¨æˆ‘ä»¬æœ‰äº†å˜é‡çš„å€¼ï¼Œ

the function `getPersonInfo` can return the string Sarah is 22 and lives in San Francisco ğŸ‰  
å‡½æ•° `getPersonInfo` å¯ä»¥è¿”å›å­—ç¬¦ä¸² Sarah is 22 and lives in San Francisco ğŸ‰


We can go down the scope chain, but we can't go up the scope chain.  
æˆ‘ä»¬å¯ä»¥å‘ä¸‹ç§»åŠ¨ä½œç”¨åŸŸé“¾ï¼Œä½†ä¸èƒ½å‘ä¸Šç§»åŠ¨ä½œç”¨åŸŸé“¾ã€‚


[JavaScript Visualized: Scope (Chain)](https://dev.to/lydiahallie/javascript-visualized-scope-chain-13pd)