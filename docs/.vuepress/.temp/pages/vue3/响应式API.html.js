import comp from "/home/yanbeirong/www/myblog/docs/.vuepress/.temp/pages/vue3/响应式API.html.vue"
const data = JSON.parse("{\"path\":\"/vue3/%E5%93%8D%E5%BA%94%E5%BC%8FAPI.html\",\"title\":\"\",\"lang\":\"en-US\",\"frontmatter\":{},\"headers\":[{\"level\":2,\"title\":\"响应式: 工具函数\",\"slug\":\"响应式-工具函数\",\"link\":\"#响应式-工具函数\",\"children\":[]},{\"level\":2,\"title\":\"响应式：进阶函数\",\"slug\":\"响应式-进阶函数\",\"link\":\"#响应式-进阶函数\",\"children\":[]}],\"git\":{\"updatedTime\":1728435449000,\"contributors\":[{\"name\":\"BaronYan\",\"email\":\"1229598328@qq.com\",\"commits\":1}]},\"filePathRelative\":\"vue3/响应式API.md\",\"excerpt\":\"<h2>响应式: 工具函数</h2>\\n<ul>\\n<li><code>isRef()</code>\\n<ul>\\n<li>检查某个值是否为 <code>ref</code>。</li>\\n</ul>\\n</li>\\n<li><code>isProxy()</code>\\n<ul>\\n<li>检查一个对象是否是由 <code>reactive()</code>、<code>readonly()</code>、<code>shallowReactive()</code> 或 <code>shallowReadonly()</code> 创建的代理。</li>\\n</ul>\\n</li>\\n<li><code>isReactive()</code>\\n<ul>\\n<li>检查一个对象是否是由 <code>reactive()</code> 或 <code>shallowReactive()</code> 创建的代理。</li>\\n</ul>\\n</li>\\n<li><code>isReadonly()</code>\\n<ul>\\n<li>检查传入的值是否为只读对象。只读对象的属性可以更改，但他们不能通过传入的对象直接赋值。</li>\\n</ul>\\n</li>\\n<li><code>unref()</code>\\n<ul>\\n<li>如果参数是 <code>ref</code>，则返回内部值，否则返回参数本身。这是 <code>val = isRef(val) ? val.value : val</code> 计算的一个语法糖。</li>\\n</ul>\\n</li>\\n<li><code>toRef()</code>\\n<ul>\\n<li>可以将值、<code>refs</code> 或 <code>getters</code> 规范化为 refs (3.3+)。也可以基于响应式对象上的一个属性，创建一个对应的 <code>ref</code>。这样创建的 <code>ref</code> 与其源属性保持同步：改变源属性的值将更新 <code>ref</code> 的值，反之亦然。</li>\\n</ul>\\n</li>\\n<li><code>toRefs()</code>\\n<ul>\\n<li>将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 toRef() 创建的。</li>\\n</ul>\\n</li>\\n<li><code>toValue()</code>\\n<ul>\\n<li><code>toValue()</code> 的设计目的是将 <code>ref</code> 或 <code>getter</code> 规范化为值。如果参数是 <code>ref</code>，它会返回 <code>ref</code> 的值；如果参数是函数，它会调用函数并返回其返回值。否则，它会原样返回参数。它的工作方式类似于 <code>unref()</code>，但对函数有特殊处理。</li>\\n</ul>\\n</li>\\n</ul>\"}")
export { comp, data }
