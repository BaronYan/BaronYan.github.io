import{_ as n,c as s,o as a,d as e}from"./app-1er_rJpx.js";const t={},l=e(`<p><a href="https://laravel.com/docs/11.x/requests" target="_blank" rel="noopener noreferrer">requests</a></p><p>Laravel 的 <code>Illuminate\\Http\\Request</code> 类提供了一种面向对象的方式，可以与应用程序正在处理的当前 HTTP 请求进行交互，并检索与请求一起提交的输入、cookie 和文件。</p><p><a href="https://laravel.com/docs/11.x/validation#creating-form-requests" target="_blank" rel="noopener noreferrer">表单请求验证</a> 表单请求是封装了自己的验证和授权逻辑的自定义请求类。</p><h2 id="表单请求验证" tabindex="-1"><a class="header-anchor" href="#表单请求验证"><span>表单请求验证</span></a></h2><p>创建表单请求类的命令如下所示：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line">php artisan make:request StorePostRequest</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Laravel 生成的每个表单请求都有两个方法：<code>authorize</code> 和 <code>rules</code> :</p><ul><li><code>authorize</code> 方法负责确定当前经过身份验证的用户是否可以执行请求所代表的操作</li><li><code>rules</code> 方法返回应适用于请求数据的验证规则 <ul><li>如果验证失败，将生成重定向响应以将用户送回其之前的位置。错误还将闪现到会话中，以便显示。</li><li>如果请求是 XHR 请求，将向用户返回带有 422 状态代码的 HTTP 响应，其中包括验证错误的 JSON 表示。</li></ul></li></ul><div class="language-php line-numbers-mode" data-highlighter="prismjs" data-ext="php" data-title="php"><pre class="language-php"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">rules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">array</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token punctuation">[</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;title&#39;</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">&#39;required|unique:posts|max:255&#39;</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;body&#39;</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">&#39;required&#39;</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://laravel.com/docs/11.x/precognition" target="_blank" rel="noopener noreferrer">Laravel Precognition</a> 可以为用户提供实时验证体验，而无需在前端 Vue 应用程序中重复验证规则。</p><ul><li>首先，要为路由启用预识别，HandlePrecognitiveRequests应将中间件添加到路由定义中。您还应该创建一个表单请求来容纳路由的验证规则：</li></ul><h2 id="request-validated" tabindex="-1"><a class="header-anchor" href="#request-validated"><span>request-&gt;validated</span></a></h2><p><code>$data = $request-&gt;validated();</code> 可以获取到经过验证的请求数据。</p><ol><li>默认情况下，<code>validated()</code> 方法只会返回在 WarehouseRequest 类的 <code>rules()</code> 方法中定义了验证规则的字段。</li><li>如果请求中包含了未在验证规则中定义的字段，这些字段不会被包含在 <code>validated()</code> 方法的返回结果中。</li><li>但是，Laravel 提供了一种方法可以包含未经验证的字段。在 WarehouseRequest 类中，你可以重写 <code>passedValidation()</code> 方法来实现这一点。</li></ol><p>例如：</p><div class="language-php line-numbers-mode" data-highlighter="prismjs" data-ext="php" data-title="php"><pre class="language-php"><code><span class="line"><span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function-definition function">passedValidation</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样做会将所有请求数据合并到已验证的数据中，包括那些没有定义验证规则的字段。</p><p>如果你只想获取特定的未验证字段，可以这样做：</p><div class="language-php line-numbers-mode" data-highlighter="prismjs" data-ext="php" data-title="php"><pre class="language-php"><code><span class="line"><span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function-definition function">passedValidation</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token punctuation">[</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;some_field&#39;</span> <span class="token operator">=&gt;</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">input</span><span class="token punctuation">(</span><span class="token string single-quoted-string">&#39;some_field&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你想获取所有字段，包括未验证的，你可以直接使用 <code>$request-&gt;all()</code> 而不是 <code>$request-&gt;validated()</code>。但这样做会失去验证的安全性优势。</p><p>总的来说，默认情况下，<code>validated()</code> 方法只返回经过验证的字段。如果你需要未经验证的字段，你需要额外的步骤或使用其他方法。在处理敏感数据时，建议只使用经过验证的数据，以确保数据的安全性和有效性。</p>`,21),p=[l];function i(o,c){return a(),s("div",null,p)}const d=n(t,[["render",i],["__file","表单验证.html.vue"]]),u=JSON.parse('{"path":"/laravel/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81.html","title":"","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"表单请求验证","slug":"表单请求验证","link":"#表单请求验证","children":[]},{"level":2,"title":"request->validated","slug":"request-validated","link":"#request-validated","children":[]}],"git":{"updatedTime":1727187215000,"contributors":[{"name":"BaronYan","email":"1229598328@qq.com","commits":3}]},"filePathRelative":"laravel/表单验证.md","excerpt":"<p><a href=\\"https://laravel.com/docs/11.x/requests\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">requests</a></p>\\n<p>Laravel 的 <code>Illuminate\\\\Http\\\\Request</code> 类提供了一种面向对象的方式，可以与应用程序正在处理的当前 HTTP 请求进行交互，并检索与请求一起提交的输入、cookie 和文件。</p>\\n<p><a href=\\"https://laravel.com/docs/11.x/validation#creating-form-requests\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">表单请求验证</a> 表单请求是封装了自己的验证和授权逻辑的自定义请求类。</p>"}');export{d as comp,u as data};
