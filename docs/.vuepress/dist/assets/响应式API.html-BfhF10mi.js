import{_ as e,c as o,o as l,d as c}from"./app-Jjiyxt7X.js";const d={},i=c('<h2 id="响应式-工具函数" tabindex="-1"><a class="header-anchor" href="#响应式-工具函数"><span>响应式: 工具函数</span></a></h2><ul><li><code>isRef()</code><ul><li>检查某个值是否为 <code>ref</code>。</li></ul></li><li><code>isProxy()</code><ul><li>检查一个对象是否是由 <code>reactive()</code>、<code>readonly()</code>、<code>shallowReactive()</code> 或 <code>shallowReadonly()</code> 创建的代理。</li></ul></li><li><code>isReactive()</code><ul><li>检查一个对象是否是由 <code>reactive()</code> 或 <code>shallowReactive()</code> 创建的代理。</li></ul></li><li><code>isReadonly()</code><ul><li>检查传入的值是否为只读对象。只读对象的属性可以更改，但他们不能通过传入的对象直接赋值。</li></ul></li><li><code>unref()</code><ul><li>如果参数是 <code>ref</code>，则返回内部值，否则返回参数本身。这是 <code>val = isRef(val) ? val.value : val</code> 计算的一个语法糖。</li></ul></li><li><code>toRef()</code><ul><li>可以将值、<code>refs</code> 或 <code>getters</code> 规范化为 refs (3.3+)。也可以基于响应式对象上的一个属性，创建一个对应的 <code>ref</code>。这样创建的 <code>ref</code> 与其源属性保持同步：改变源属性的值将更新 <code>ref</code> 的值，反之亦然。</li></ul></li><li><code>toRefs()</code><ul><li>将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 toRef() 创建的。</li></ul></li><li><code>toValue()</code><ul><li><code>toValue()</code> 的设计目的是将 <code>ref</code> 或 <code>getter</code> 规范化为值。如果参数是 <code>ref</code>，它会返回 <code>ref</code> 的值；如果参数是函数，它会调用函数并返回其返回值。否则，它会原样返回参数。它的工作方式类似于 <code>unref()</code>，但对函数有特殊处理。</li></ul></li></ul><h2 id="响应式-进阶函数" tabindex="-1"><a class="header-anchor" href="#响应式-进阶函数"><span>响应式：进阶函数</span></a></h2><p>https://cn.vuejs.org/api/reactivity-advanced.html#shallowref</p>',4),n=[i];function a(t,r){return l(),o("div",null,n)}const s=e(d,[["render",a],["__file","响应式API.html.vue"]]),f=JSON.parse('{"path":"/vue3/%E5%93%8D%E5%BA%94%E5%BC%8FAPI.html","title":"","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"响应式: 工具函数","slug":"响应式-工具函数","link":"#响应式-工具函数","children":[]},{"level":2,"title":"响应式：进阶函数","slug":"响应式-进阶函数","link":"#响应式-进阶函数","children":[]}],"git":{"updatedTime":1728435449000,"contributors":[{"name":"BaronYan","email":"1229598328@qq.com","commits":1}]},"filePathRelative":"vue3/响应式API.md","excerpt":"<h2>响应式: 工具函数</h2>\\n<ul>\\n<li><code>isRef()</code>\\n<ul>\\n<li>检查某个值是否为 <code>ref</code>。</li>\\n</ul>\\n</li>\\n<li><code>isProxy()</code>\\n<ul>\\n<li>检查一个对象是否是由 <code>reactive()</code>、<code>readonly()</code>、<code>shallowReactive()</code> 或 <code>shallowReadonly()</code> 创建的代理。</li>\\n</ul>\\n</li>\\n<li><code>isReactive()</code>\\n<ul>\\n<li>检查一个对象是否是由 <code>reactive()</code> 或 <code>shallowReactive()</code> 创建的代理。</li>\\n</ul>\\n</li>\\n<li><code>isReadonly()</code>\\n<ul>\\n<li>检查传入的值是否为只读对象。只读对象的属性可以更改，但他们不能通过传入的对象直接赋值。</li>\\n</ul>\\n</li>\\n<li><code>unref()</code>\\n<ul>\\n<li>如果参数是 <code>ref</code>，则返回内部值，否则返回参数本身。这是 <code>val = isRef(val) ? val.value : val</code> 计算的一个语法糖。</li>\\n</ul>\\n</li>\\n<li><code>toRef()</code>\\n<ul>\\n<li>可以将值、<code>refs</code> 或 <code>getters</code> 规范化为 refs (3.3+)。也可以基于响应式对象上的一个属性，创建一个对应的 <code>ref</code>。这样创建的 <code>ref</code> 与其源属性保持同步：改变源属性的值将更新 <code>ref</code> 的值，反之亦然。</li>\\n</ul>\\n</li>\\n<li><code>toRefs()</code>\\n<ul>\\n<li>将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 toRef() 创建的。</li>\\n</ul>\\n</li>\\n<li><code>toValue()</code>\\n<ul>\\n<li><code>toValue()</code> 的设计目的是将 <code>ref</code> 或 <code>getter</code> 规范化为值。如果参数是 <code>ref</code>，它会返回 <code>ref</code> 的值；如果参数是函数，它会调用函数并返回其返回值。否则，它会原样返回参数。它的工作方式类似于 <code>unref()</code>，但对函数有特殊处理。</li>\\n</ul>\\n</li>\\n</ul>"}');export{s as comp,f as data};
