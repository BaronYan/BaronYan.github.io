


## 读写锁

从电子表格中读取数据不会有什么麻烦，即使很多人同时读取也不会有问题。因为读取操作不会修改数据，所以不太可能出错。
如果有人试图删除`A25`单元格中的内容，而其他人正在读取电子表格，会发生什么情况？
这要视情况而定，读取者可能遇到报错退出，也可能得到不一致的数据视图。为安全起见，即使是从电子表格中读取数据也需要特别小心。

电子表格就是一张简单的数据库表。修改数据库表中的记录，和删除或者修改电子表格文件中的单元格内容十分类似。

<p class="bg-yellow-200">处理并发 <span class="font-bold">读/写</span> 访问的系统通常实现一个由两种锁类型组成的锁系统。这两种锁通常被称为 <span class="font-bold">共享锁(shared lock)</span> 和 <span class="font-bold">排他锁(exclusive lock)</span>，也叫 <span class="font-bold">读锁(read lock)</span>和 <span class="font-bold">写锁(writelock)</span> 。</p>

锁的概念可以如下描述：
- 资源上的读锁是共享的，或者说是相互不阻塞的。多个客户端可以同时读取同一个资源而互不干扰。
- 写锁则是排他的，也就是说，一个写锁既会阻塞读锁也会阻塞其他的写锁，这是出于安全策略的考虑，只有这样才能确保在特定的时间点只有一个客户端能执行写入，并防止其他客户端读取正在写入的资源。

MySQL提供了多种存储引擎，而不是单一的通用解决方案。下面让我们来看两种最重要的锁策略。

**表锁(table lock)**  
表锁是MySQL中最基本也是开销最小的锁策略。表锁非常类似于电子表格的锁机制：它会锁定整张表。当客户端想对表进行写操作（插入、删除、更新等）时，需要先获得一个写锁，这会阻塞其他客户端对该表的所有读写操作。只有没有人执行写操作时，其他读取的客户端才能获得读锁，读锁之间不会相互阻塞。表锁有一些变体，可以在特定情况下提高性能。例如，READ LOCAL表锁支持某些类型的并发写操作。写锁队列和读锁队列是分开的，但写锁队列的优先级绝对高于读队列。

**行级锁(row lock)**  
使用行级锁可以最大程度地支持并发处理（也带来了最大的锁开销）。回到电子表格的类比，行级锁等同于锁定电子表格中的某一行。这种策略允许多人同时编辑不同的行，而不会阻塞彼此。这使得服务器可以执行更多的并发写操作，带来的代价则是需要承担更多开销，以跟踪谁拥有这些行级锁、已经锁定了多长时间、行级锁的类型，以及何时该清理不再需要的行级锁。行级锁是在存储引擎而不是服务器中实现的。服务器通常不清楚存储引擎中锁的实现方式。



## 事务

事务就是一组SQL语句，作为一个工作单元以原子方式进行处理。如果数据库引擎能够成功地对数据库应用整组语句，那么就执行该组语句。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么整组语句都不执行。也就是说，作为事务的一组语句，要么全部执行成功，要么全部执行失败。

### ACID事务的概念

ACID代表原子性(atomicity)、一致性(consistency)、隔离性(isolation)和持久性(durability)。

- 原子性(atomicity)
  - 一个事务必须被视为一个不可分割的工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。
- 一致性(consistency)
  - 数据库总是从一个一致性状态转换到下一个一致性状态。一致性确保了，即使在执行第3、4条语句之间时系统崩溃，支票账户中也不会损失200美元。如果事务最终没有提交，该事务所做的任何修改都不会被保存到数据库中。
- 隔离性(isolation)
  - 通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的，这就是隔离性带来的结果。当执行完第3条语句、第4条语句还未开始时，此时有另外一个账户汇总程序开始运行，其看到的支票账户的余额并没有被减去200美元。后面我们讨论隔离级别(isolation level)的时候，会发现为什么我们要说“通常来说”是不可见的。
- 持久性(durability)
  - 一旦提交，事务所做的修改就会被永久保存到数据库中。此时即使系统崩溃，数据也不会丢失。持久性是一个有点模糊的概念，实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能有100%的持久性保障（如果数据库本身就能做到真正的持久性，那么备份又怎么能增加持久性呢？）。

## 死锁

死锁是指两个或多个事务相互持有和请求相同资源上的锁，产生了循环依赖。
当多个事务试图以不同的顺序锁定资源时会导致死锁。当多个事务锁定相同的资源时，也可能会发生死锁。

例如，设想运行下面两个针对主键为(stock_id，date)的StockPrice表的事务：

事务1

```sql
START TRANSACTION 
UPDATE StockPrice SET close = 45.50 WHERE stock_id = 4 AND date = '2024-05-01';
UPDATE StockPrice SET close = 19.80 WHERE stock_id = 3 AND date = '2024-05-02';
COMMIT;
```

事务2

```sql
START TRANSACTION 
UPDATE StockPrice SET high = 20.12 WHERE stock_id = 3 AND date = '2024-05-02';
UPDATE StockPrice SET high = 47.20 WHERE stock_id = 4 AND date = '2024-05-01';
COMMIT;
```
每个事务都开始执行第一个查询，在处理过程中会更新一行数据，同时在主键索引和其他唯一索引中将该行锁定。然后，每个事务将在第二个查询中尝试更新第二行数据，却发现该行已经被锁定。这两个事务将永远等待对方完成，除非有其他因素介入解除死锁。

为了解决这个问题，数据库系统实现了各种死锁检测和锁超时机制。更复杂的系统，比如InnoDB存储引擎，检测到循环依赖后会立即返回一个错误信息。这可能是一件好事——否则，死锁将表现为非常缓慢的查询。还有一种方式，当超过锁等待超时的时间限制后直接终止查询，这样做通常来说不太好。InnoDB目前处理死锁的方式是将持有最少行级排他锁的事务回滚（这是一种最容易回滚的近似算法）。

死锁的产生有双重原因：有些是因为真正的数据冲突，这种情况通常很难避免，但有些则完全是由于存储引擎的实现方式导致的。

一旦发生死锁，如果不回滚其中一个事务（部分或全部），就无法打破死锁。对于事务型的系统，这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新从头开始执行被回滚的事务即可，除非又遇到另一个死锁。